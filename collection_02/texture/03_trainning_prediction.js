var geometry = /* color: #d63000 */ee.Geometry.MultiPoint();
/* 
 * MAPBIOMAS SOIL
 * @contact: contato@mapbiomas.org
 * @date: November 19, 2024
 * 
 * SCRIPT 3: PREDICTING AND MAPPING SOIL GRANULOMETRY (CLAY, SAND, SILT)
 * 
 * **Purpose**:
 * This script is part of the MapBiomas Soil initiative for producing the **beta series of soil granulometry and texture**. 
 * It predicts soil granulometric fractions (clay, sand, silt) across Brazil by using pre-trained Random Forest models 
 * and depth-specific training matrices (accessible via the MapBiomas Soil repository). The predictions are performed 
 * on the log-ratio scale and subsequently converted back to original proportions (%) for mapping and visualization.
 * 
 * **Features**:
 * - Access depth-specific training matrices and environmental covariates from the repository.
 * - Perform log-ratio predictions for granulometric fractions at 5 cm, 15 cm, and 25 cm depths.
 * - Convert log-ratio predictions back to clay, sand, and silt contents in percentage.
 * - Display granulometry maps in the Google Earth Engine (GEE) console.
 * - Output model performance statistics in the GEE console.
 * 
 * **Outputs**:
 * - Granulometry maps displayed (% content of clay, sand, and silt) at 30m resolution for target depths (5 cm, 15 cm, 25 cm).
 * - Model performance metrics displayed in the console.
 * 
 * **Notes**:
 * - Ensure access to the required training matrices and covariate module in the GEE repository.
 * - Predictions for each depth use upper-layer predictions as covariates to maintain spatial and depth consistency.
 * - Maps and statistics generated by this script are for visualization and validation purposes.
 * 
 * **Contact**:
 * - For issues related to covariate access or integration, contact Wallace Silva at wallace.silva@ipam.org.br
 * - Coordination: Dra. Taciara Zborowski Horst (taciaraz@professores.utfpr.edu.br)
 * - General questions: MapBiomas Soil Team: contato@mapbiomas.org
 */

 
// --- VERSIONING
var seed = 2021; // inicio do mapbiomas solo

var steps = [
  //////////////     step 0 -> 0-10 cm
  {
    matrix:'beta_000_010',
    version:'v0',
    profundidade_alvo:'000_010cm',
    target_depth:'depth_5'
  },
  //////////////     step 1 -> 10-20 cm
  {
    matrix:'beta_010_020',
    version:'v0',
    profundidade_alvo:'010_020cm',
    target_depth:'depth_15'
  },
  //////////////     step 2 -> 20-30 cm
  {
    matrix:'beta_020_030',
    version:'v0',
    profundidade_alvo:'020_030cm',
    target_depth:'depth_25'
  }
];

// ATENÇÃO, lembre de conferir qual é a etapa que esta rodando neste momento, 
// ja que as etapas de processamento das bandas de mais profundas, depende do 
// processamento previo das bandas mais proximas a superficie;

// steps[0] -> 0-10 cm, steps[1] -> 10-20 cm, steps[2] -> 20-30 cm
var step = steps[1]; 

var matrix = step.matrix;
var version = step.version;
var profundidade_alvo = step.profundidade_alvo;
var target_depth = step.target_depth;

// export params
var assetId = 'projects/mapbiomas-workspace/SOLOS/PRODUTOS_C02/mapbiomas_soil_collection2_granulometry-' + version;
var default_name = 'mapbiomas_soil_collection2_';
var initiave_and_you = 'GT_SOLO_WS';

///////////////////// LOG
// Check if the collection exists using .evaluate()
ee.ImageCollection(assetId).size().evaluate(function (collectionSize) {
  if (collectionSize === undefined) {
    var newCollectionPath = assetId;
    var assetType = 'ImageCollection';
    // Commented out the creation of the collection
    // ee.data.createAsset({
    //   "type": assetType
    // }, newCollectionPath);
    // Instead, print a message prompting the user to create the collection manually
    print(ui.Label('⚠️ Por favor, crie uma coleção de imagens chamada:'), ui.Label(outputPath));
  }
});


///////////////////////////////////////////////////////////////////////////////////////////
// --- DEFINITION OF DATA FOR PREDICTION
matrix = 'projects/mapbiomas-workspace/SOLOS/AMOSTRAS/MATRIZES/granulometry/' + matrix;
var datatraining = ee.FeatureCollection(matrix);
print('datatraining', datatraining.limit(10));

var datatraining_columns = datatraining.first().propertyNames();
print(datatraining_columns);

var datatraining = ee.FeatureCollection(matrix)
  .filter(ee.Filter.notNull(['id', 'log_silt_sand','log_clay_sand', 'system:index']));
  
///////////////////////////////////////////////////////////////////////////////////////////
// --- IMPORTING COVARIATES MODULE
// Importing covariates module
var covariates = require('users/wallacesilva/mapbiomas-solos:PRODUCTION/2024_beta_granulometria/1_covariate_source');
var static_covariates = covariates.static_covariates();
print('static_covariates',static_covariates);
// Retrieve property names from datatraining
var datatraining_columns = datatraining.first().propertyNames();
print('Bands in datatraining_columns:', datatraining_columns);

// Rename 'depth_5' to 'depth' in static_covariates
var renamed_static_covariates = static_covariates.rename(
  static_covariates.bandNames().map(function(bandName) {
    return ee.String(bandName).replace('depth_25', 'depth');
  })
);

// Print renamed band names to verify
print('Renamed Bands:', renamed_static_covariates.bandNames());

var static_covariates_module = renamed_static_covariates.bandNames();
//print('Bands in static_covariates_module:', static_covariates_module);
// Filter static_covariates band names based on items in datatraining_columns

var static_covariates_names = static_covariates_module.filter(ee.Filter.inList('item', datatraining_columns));
//print('static_covariates names:', static_covariates_names);

// Select bands in static_covariates based on static_covariates_names
var selected_static_covariates = renamed_static_covariates.select(static_covariates_names);

// Print the selected bands to verify
//print('Selected bands in static_covariates:', selected_static_covariates.bandNames());

///////////////////////////////////////////////////////////////////////////////////////////
//  ---- MODEL DEFINITIONS
var rf_params = {
  ntree: 100,
  mtry: 16,
  nodesize: 2,
  maxNodes: 30,
  sampsize: 0.632
};
///////////////////////////////////////////////////////////////////////////////////////////
// --- TRAINING THE PREDICTIVE MODEL --- log_clay_sand

var randomForestModel_log_clay_sand = ee.Classifier
  .smileRandomForest({
    numberOfTrees: rf_params.ntree,
    variablesPerSplit: rf_params.mtry,
    minLeafPopulation: rf_params.nodesize,
    bagFraction: rf_params.sampsize,
    seed: seed
  })
  .setOutputMode("REGRESSION")
  .train({
    features: datatraining,
    classProperty: "log_clay_sand",
    inputProperties: static_covariates_names
  });
  
  print(randomForestModel_log_clay_sand)

// --- TRAINING THE PREDICTIVE MODEL --- log_silt_sand
var randomForestModel_log_silt_sand = ee.Classifier
  .smileRandomForest({
    numberOfTrees: rf_params.ntree,
    variablesPerSplit: rf_params.mtry,
    minLeafPopulation: rf_params.nodesize,
    bagFraction: rf_params.sampsize,
    seed: seed
  })
  .setOutputMode("REGRESSION")
  .train({
    features: datatraining,
    classProperty: "log_silt_sand",
    inputProperties: static_covariates_names
  });

///////////////////////////////////////////////////////////////////////////////////////////
// --- SPATIAL PREDICTION ---
var biomas = ee.FeatureCollection('projects/mapbiomas-workspace/AUXILIAR/biomas_IBGE_250mil');
var aoi = biomas;
var aoi_img = ee.Image().paint(aoi).eq(0);
var aoi_bounds = aoi.geometry().bounds();

var prediction_log_clay_sand = selected_static_covariates
  .classify(randomForestModel_log_clay_sand)
  .rename('log_clay_sand')
  .float();
print('prediction_log_clay_sand' + profundidade_alvo, prediction_log_clay_sand);

var prediction_log_silt_sand = selected_static_covariates
  .classify(randomForestModel_log_silt_sand)
  .rename('log_silt_sand')
  .float();
print('prediction_log_silt_sand' + profundidade_alvo, prediction_log_silt_sand);

// map_sand = (1/(exp(log_clay_sand)+exp(log_silt_sand) + 1))*100
var map_sand = ee.Image()
  .expression({
    expression: '(1/(exp(log_clay_sand)+exp(log_silt_sand) + 1))*100',
    map: {
      log_clay_sand: prediction_log_clay_sand,
      log_silt_sand: prediction_log_silt_sand
    }
  })
  .round()  // Round 
  .rename('prediction_sand');
//print('map_sand'+ profundidade_alvo, map_sand);

  
// map_clay = (exp(log_clay_sand)/(exp(log_clay_sand)+exp(log_silt_sand)+1))*100
var map_clay = ee.Image()
  .expression({
    expression: '(exp(log_clay_sand)/(exp(log_clay_sand)+exp(log_silt_sand)+1))*100',
    map: {
      log_clay_sand: prediction_log_clay_sand,
      log_silt_sand: prediction_log_silt_sand
    }
  })
  .round()  // Round 
  .rename('prediction_clay');
//print('map_clay'+ profundidade_alvo, map_clay);


// map_silt = (exp(log_silt_sand)/(exp(log_clay_sand)+exp(log_silt_sand) + 1))*100
var map_silt = ee.Image()
  .expression({
    expression: '(exp(log_silt_sand)/(exp(log_clay_sand)+exp(log_silt_sand) + 1))*100',
    map: {
      log_clay_sand: prediction_log_clay_sand,
      log_silt_sand: prediction_log_silt_sand
    }
  })
  .round()  // Round 
  .rename('prediction_silt');
//print('map_silt'+ profundidade_alvo, map_silt);


var final_images = [
  ['sand', map_sand],
  ['silt', map_silt],
  ['clay', map_clay],
];

///////////////////////////////////////////////////////////////////////////////////////////
// Export maps
final_images.forEach(function(list) {
  
  var description = default_name + list[0] +'_percent_'+ profundidade_alvo + '-' + version;
  var image = list[1];
  exportPerSupercarta(image.float()
    .set({
      'pepth': profundidade_alvo,
      'version': version,
      'initiative':'MAPBIOMAS SOLO',
      'source':'LABORATÓRIO DE PEDOMETRIA',
      'type': list[0],
      'matrix':matrix
    }), assetId, description,aoi_bounds);
});


function exportPerSupercarta(image, output, description,filter_bounds) {
  var cartas = ee.FeatureCollection('projects/mapbiomas-workspace/AUXILIAR/cartas')
    .filterBounds(filter_bounds)
    .map(function (feature) {
      return feature.set({
        supercarta: feature.getString('grid_name').slice(0,-4)
      });
    });

  var supercartas = cartas.aggregate_array('supercarta').distinct().sort();
  supercartas.evaluate(function (list) {
    list.forEach(function (supercarta) {

      var newDescription = description + '_' + supercarta;
      var supercartaFeature = cartas.filter(ee.Filter.eq('supercarta', supercarta));
      var imageToExport = image.clip(supercartaFeature.geometry()).set({
        carta: supercarta,
        name: newDescription,
        group: description
      });

      Export.image.toAsset({
        image: imageToExport,
        description: initiave_and_you + '-' +newDescription,
        assetId: output + '/' + newDescription,
        pyramidingPolicy: "median",
        region: supercartaFeature.geometry(),
        scale: 30,
        maxPixels: 1e13,
      });
    });
  });
}

///////////////////////////////////////////////////////////////////////////////////////////
// VISUALIZAÇÃO CONSOLE
// DEFINE COLOR PARAMETERS
var visual_params_log = {
  min: -2,
  max: 2,
  palette: [
    'ffffe5', 'fff7bc', 'fee391', 'fec44f', 'fe9929', 'ec7014', 'cc4c02', '993404', '662506'
  ]
};

var vis_params_granulometry = {
  min: 0,
  max: 100,
  palette: [
//    'e5f5e0', 'c7e9c0', 'a1d99b', '74c476', '41ab5d', '238b45', '006d2c', '00441b' // verde
//   'fff5f0', 'fee0d2', 'fcbba1', 'fc9272', 'fb6a4a', 'ef3b2c', 'cb181d', 'a50f15', '67000d' // vermelho
//      'ffffd9', 'edf8b1', 'c7e9b4', '7fcdbb', '41b6c4', '1d91c0', '225ea8', '253494', '081d58' //YlGnBu
      'fff5eb', 'fee6ce', 'fdd0a2', 'fdae6b', 'fd8d3c', 'f16913', 'd94801', 'a63603', '7f2704'
  ]
};


// ADD MAPAS
Map.addLayer(map_sand, vis_params_granulometry, 'prediction_sand');
Map.addLayer(map_silt, vis_params_granulometry, 'prediction_silt');
Map.addLayer(map_clay, vis_params_granulometry, 'prediction_clay');



// ADD PAINEL LEGENDA 
// Create the legend panel
var legend = ui.Panel({
  style: {
    position: 'bottom-left',
    padding: '8px',
  }
});

// Add legend title
legend.add(ui.Label('Soil particle size distribuition (%) '));

// Add color bar
legend.add(ui.Thumbnail({
  image: ee.Image.pixelLonLat().select(0),
  params: {
    bbox: [0, 0, 1, 0.1],
    dimensions: '100x10',
    palette: vis_params_granulometry.palette
  },
  style: {stretch: 'horizontal'}
}));

// Create labels from 0 to 100 by increments of 10
var labels = [];
for (var i = 0; i <= 100; i += 10) {
  labels.push(ui.Label(i.toString(), {margin: '4px'}));
}

// Arrange labels in a horizontal layout
legend.add(ui.Panel(labels, ui.Panel.Layout.flow('horizontal')));

// Add the legend to the map
Map.add(legend);
// FIM LEGENDA

/////////
// --- RANDOM FOREST MODEL ANALYSIS - ln_SILT_SAND - - - - - - - \\
var dict = randomForestModel_log_clay_sand.explain();
print("Random Forest Explain ln_silt_sand", dict, 'Number of samples: ', datatraining.size());

var error = ee.String(ee.Dictionary(dict).get('outOfBagErrorEstimate'));
dict = ee.Dictionary(ee.Dictionary(dict).get('importance'));
var keys = dict.keys().sort(dict.values()).reverse();
var values = dict.values(keys);
var rows = keys.zip(values);
var dict_b = {};

rows = rows.map(function(list) {
  return {c: ee.List(list).map(function(n) { return {v: n}; })};
});

var dataTable = {
  cols: [{id: 'band', label: 'Band', type: 'string'},
        {id: 'importance', label: 'Importance', type: 'number'}],
  rows: rows
};

ee.Dictionary(dataTable).evaluate(function(result) {
  var chart = ui.Chart(result)
    .setChartType('BarChart')
    .setOptions({
      title: 'Random Forest Covariates Importance ln_silt_sand',
      legend: {position: 'none'},
      hAxis: {title: 'Covariates'},
      vAxis: {title: 'Importance'},
      viewWindow: {
        max: 100,
        min: 0
      }      
    });
    
  chart.style()
    .set('height', '256px')
    .set('margin', '0px');
  
  var chart_panel = ui.Panel({
    widgets: [chart],
    layout: ui.Panel.Layout.Flow('vertical'),
  });
    
  print(chart_panel);
  
  var chart_table = ui.Chart(result).setChartType('Table');
  print(chart_table);
  
  error.evaluate(function(num) {
    var error_label = ui.Label({
      value: 'Error estimate: ' + ('' + num).slice(0, 4),
      style: {},
    });
    
    chart_panel.add(error_label);
  });
});
